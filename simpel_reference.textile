---
layout: default
title: SimPEL Language Reference
---

h2(#basic_lang). Basic Language Constructs

Before diving into language elements, introducing a few common definitions is necessary:

{% highlight text %}
ns_id         :  (ID '::')? ID;
block         :  '{' proc_stmt+ '}';
param_block   :  '{' ('|' ID (',' in+=ID)* '|')? proc_stmt+ '}';
body  :  block | proc_stmt;
{% endhighlight %}

A ns_id is an identifier preceded by an optional namespace prefix, with '::' as separator. For example _Foo_ or _myns::Foo_ are valid ns_id instances. A block is pretty self explanatory, it's at least one process statement between curly braces. Like { reply(); }. A param_block is like a block but includes some parameters, provided between pipe characters ('|') and separated by commas. A valid param_block could be { |a| reply(a); }. A body is either a block or a single process statement.

All statements in SimPEL are required to end with a semicolon.

h3(#process). Process

The _process_ construct is the root of a process definition. It's also the root "scope":#scope.  It declares a name as a ns_id and contains the whole process body as a sequence of statements:

{% highlight text %}
process  :  'process' ns_id body;
{% endhighlight %}

A process with no namespace prefix will be created under the default http://ode.apache.org/simpel/1.0/definition namespace. In most cases you don't really need to worry about namespaces, name collision in processes isn't that common.

Examples:

{% highlight simpel %}
process Purchase {
   ...
}

process myns::ServiceMock {
}
{% endhighlight %}

h3(#conditions). Conditions

Conditions are pretty much what you would expect:

{% highlight text %}
if: 'if' '(' expr ')' body ('else' body)?
{% endhighlight %}

Any valid "expression":#expr can be used in an _if_ as long as it's boolean (returns true or false). The _else_ branch is optional. At the moment there's %[todo]no specific syntax for chaining% _else_ and _if_ (like elseif) although that should come soon.

The _else_ branches associate to the closer previous _if_ where there's ambiguity.

Example:

{% highlight simpel %}
if (updatedTask.data.accept == "true") {
  ...
} else {
  ...
}
{% endhighlight %}

h3(#loops). Loops

The base loop is a _while_ defined this way:

{% highlight text %}
while:  'while' '(' expr ')' body
{% endhighlight %}

It's simply composed of a boolean "expression":#expr and a body. The body will be executed as long as the condition evaluates to true. The condition is tested before each execution so if it returns false when first tested, the body will never be executed.

Example:

{% highlight simpel %}
i = 0; j = 1; cur = 1;
while (cur <= counter) {
   k = i; i = j; j = k+j; cur = cur+1;
}
{% endhighlight %}

The SimPEL grammar also supports _until_, _foreach_ and _forall_ (with parallel semantics) loops but %[todo]they're unimplemented at this time%.

h3(#wait). Wait

Wait allows delayed execution, waiting for a certain period of time before completing. The delay is specified using an "ISO 8601":http://www.iso.ch/markete/8601.pdf (pdf) duration or date/time formatted string. For example P1Y2MT2H or PT2M30S are valid durations. A valid date/time is 1999-05-31T13:20:00-05:00.

Example:

{% highlight simpel %}
wait("PT1S");
{% endhighlight %}

h3(#scope). Scope

A scope is an enclosing context, grouping a range of statements. It defines variables accessibility and the availability of handlers (like "event handlers":rest_support). By itself, a scope doesn't serve any purpose but it supports the definition of other constructs:

scope:      'scope' ('(' ID ')')? body scope_stmt*;
scope_decl: onevent | onalarm | onquery | onreceive | onupdate | compensation;

A scope can be named using an identifier. It contains a body, eventually followed by several related declarations. For more information regarding the event handler (the on* elements), refer to the "RESTful Communications":#rest_support section. %[todo]Compensation and onAlarm are unimplemented at this time.%

Example:

{% highlight simpel %}
scope {
  counter = 0;
  while(counter > 0) {
    wait("PT10S");
  }
} onQuery(self) {
  links = <counter></counter>;
  links.decrement = dec;
  links.value = value;
  reply(links);
} onQuery(value) {
  reply(counter);
} onReceive(dec) {
  counter = counter - 1;
  reply(counter);
}
{% endhighlight %}

h2(#expr). Expressions

h3(#literals_op). Literals and Operators

Supported literals at this time are integers (14 or 1000), strings with escape sequences ("abc" or "\tfoo\n") and XML (<foo>bar</foo>).%[todo]Support for floats should come very soon%. %[todo]Native arrays and hashes support% is also planned (for the moment, XML partly fills that gap). Numbers have the same characteristics as in Javascript. Integers are considered reliable (numbers without a period or exponent notation) to 15 digits.

Supported operators from lower to higher precedence: 

{% highlight text %}
==, !=, <, >, <=, >=, &&, ||, +, -, *, /, ! and unary -.
{% endhighlight %}

h3(#variable). Variables and Scoping

Variable declaration in SimPEL is implicit and enclosed in the nearest scope where it's first used. A variable starts to exist when it's first assigned and stops to exist when the scope enclosing that first assignment exits. Variables can't be shadowed (where a name hides another identical name in a higher level scope), they're always redefined.

Variable assignment has a copy semantic, the content is duplicated.

h3(#other). Other Language Constructs

Other constructs like %[todo]pick, flow (with signals and joins), try/catch, with, throw, compensate, exit% will find their way in SimPEL but they're all unimplemented at this time.

h3(#e4x). E4X Support

In addition to classic expressions (like foo = bar + 4), SimPEL supports %[todo]most% of the "E4X":https://developer.mozilla.org/en/E4X specification. This translates into the following properties:

 * XML literals
 * Embed expressions in the literals using { ... } escapes.
 * Easy access to XML nodes (order.item.@id)

Detailing all the features of E4X is outside the scope of this specification, please check the "E4X specification":http://www.ecma-international.org/publications/standards/Ecma-357.htm for more.

Examples:

{% highlight simpel %}
inviteEmail = <email><to>{ vote.participants.name[m] + "@intalio.com" }</to></email>;
inviteEmail.body = "Hi, how are you?";
{% endhighlight %}

h2(#rest_support). RESTful Communications

SimPEL has several constructs to enable HTTP-based communication. The goal is to make receiving and issuing HTTP requests easy, hiding the low level details in the common case without making complicated interactions impossible. In addition to the basic HTTP support, SimPEL adds constraints to enable characteristics like idempotence or cache control.

h3(#resource). Resources

Resources are declared in a scope, are associated with a name by assignment and declare the relative path that denotes the relationship with other resources. In the default case (not other resource is provided), it's relative to the running process. Processes use resource references for the purpose of receiving requests on that resource or passing the absolute resource path. Once first assigned, resources are read-only.

A resource that specifies a static path will be instantiated by appending that path to the instance URL. A resource that specifies a path relative to another resource will be instantiated by appending that path to the URL of the other resource. We use the $ notation to reference another resource, so the path $foo/bar will append /bar to the URL denoted by the resource $foo. Note that at the time of this writing, %[todo]the $ notation isn't supported yet%.

Resources can rely on URL patterns defined between curly braces (ex: "/ballot/{name}"). The way patterns are bound to variable will be defined in the "Providing a Resource":#providing section.

Process definitions, once deployed, exist permanently with their own resource exposed under the deployment URL. The process resources react to POST requests by starting a new process execution (or process instance) that gets, from this point, its own resource. This resource is implicitly defined in all processes as _self_. 

New resources can be %[todo]instantiated during the execution of a process% even though it's unimplemented for now.

Example:

{% highlight simpel %}
cancelResource = resources("/cancel");
{% endhighlight %}

h3(#providing). Providing a Resource

The first way to provide a resource in a process is by using *_receive_*:

{% highlight text %}
receive       : receive_base param_block | receive_base SEMI;
receive_base  : 'receive' '(' ID ')';
{% endhighlight %}

The _receive_ takes a resource for parameter and waits for a POST request. Once the POST is received, it completes normally. All processes should start with a receive on _self_ called the instantiating receive. A process will reply to a POST request on an instantiating receive using the 201 (Created) status code and will provide the URL of the new process instance in the Location HTTP header.  Subsequently a process can have any number of receives, including on _self_.

The payload received by a _receive_ can either be associated to a variable using assignment or by passing it into a block. The block scopes the variable and enables a couple of shortcuts for replies.

Each _receive_ must be matched with a _reply_ on the same resource:

{% highlight text %}
reply: 'reply' '(' (ID (',' ID)?)? ')';
{% endhighlight %}

The first _reply_ parameter is used to provide the payload to be sent back to the caller. It has to be a variable, %[todo]expressions aren't accepted% at the moment. The second parameter is the resource replying from (more than one interaction can be going on at once in a process). The payload can be omitted if the response can be empty, in which case only headers will be sent back. In a block _receive_, the resource can be omitted as well, it will automatically use the same resource as the _receive_. In a block _receive_, the _reply_ can be completely omitted, in which case an implicit empty _reply_ will be inserted as the last statement in the block.

To implement a resource over recurring requests, a SimPEL process can rely on *event handlers*. Handlers are associated to a "scope":#scope and live as long as their scope. Like a _receive_, all event handlers have to be matched with a _reply_.

The _onQuery_ event handler responds to GET requests, as such it's required to have no side effect. As a consequence, an _onQuery_ can only modify variables local to its block and has read-only access to other variables (%[todo]not enforced for now).

{% highlight text %}
onquery:  'onQuery' '(' ID ')' param_block;
{% endhighlight %}

If the resource provided to _onQuery_ includes URL patterns, the block can declare parameters that will be associated to pattern element values extracted from the URL. As an example, if a resource is exposed under "/ballot/{name}" and the URL called is "/ballot/john", the _onQuery_ block can define a |name| parameter that will be initialized to "john".

%[todo]At the moment, no cache control is implemented% but the process engine can use cache control to optimize the GET method by handling conditional GETs and setting the Last-Modified/ETag headers. These are set to detect any change in the state of the process instance (which excludes responding to a GET request).

The _onReceive_ is an event handler equivalent to a classic receive:

{% highlight text %}
onreceive:  'onReceive' '(' ID ')' param_block;
{% endhighlight %}

The first block parameter defined on an _onReceive_ block will be initialized with the received payload. Subsequent block parameters are associated with eventual URL patterns.

The _onUpdate_ event handler (%[todo]unsupported for now%) is used to modify state and responds to PUT requests:

{% highlight text %}
onupdate :  'onUpdate' '(' r=ID ')' param_block;
{% endhighlight %}

Conditional PUT should be supported.

The _onDelete_ event handler (%[todo]unsupported for now%) is used to modify state and responds to DELETE requests:

{% highlight text %}
onDelete:  'onDelete' '(' r=ID ')' param_block;
{% endhighlight %}

Example (see the "Resource Fun":/resource_fun.html tutorial for the complete process):

{% highlight simpel %}
tally = resource("/tally");
ballot = resource("/ballot/{name}");
close = resource("/close");
cancel = resource("/cancel");

scope {
  receive(cancel) { |r|
    cancelResp = <vote>Vote canceled.</vote>;
    reply(cancelResp);
  }
} onQuery(self) {
  reply(vote);
} onQuery(tally) {
  currentTally = getCurrentTally(ballots);
  reply(currentTally);
} onReceive(ballot) { |b, name|
  if (voteOpen == true) {
    ballots = updateBallots(ballots, b.ballot, name);
    userBallot = getUserBallot(ballots, name);
    reply(userBallot);
  } else {
    resp = <vote>Vote is closed.</vote>;
    reply(resp);
  }
} onQuery(ballot) { |name|
  userBallot = getUserBallot(ballots, name);
  if (userBallot.length != 0) {
    reply(userBallot);
  } else {
    info = createBallotInfo(vote, self, name);
    reply(info);
  }
} onReceive(close) {
  voteOpen = false;
  finalTally = getCurrentTally(ballots);
  reply(finalTally);
}
{% endhighlight %}

h3(#calling). Calling Resources

To build a request and call a URL, the _request_ construct should be used:

{% highlight text %}
request:      request_base param_block | request_base SEMI;
request_base: 'request' '(' expr (',' STRING (',' ID)?)? ')';
{% endhighlight %}

The first parameter is an expression that must evaluate to an absolute URL string. The HTTPS URL scheme is supported. The second parameter is a case-insensitive string providing the HTTP method that should be called ("get", "put", "post", "delete"; "head" is %[todo]unsupported for now%). The third parameter is a variable providing the entity-body and the headers that will be sent in the request.

In the case of a GET request, both the method and the variable (obviously GET requests have no body) can be omitted.

HTTP headers can be provided using the _headers_ special element available on all request variables. Headers can be both set and read. Headers that normally include a dash ('-') character in the HTTP specification are replaced with an underscore ('_'), for example Content-Type becomes Content_Type. For HTTP basic authentication, a special _basicAuth_ sub-element of _headers_ can be used to set the loging and password, using elements of the same name.

Request examples:

{% highlight simpel %}
process AllMethods {
   receive(self) { |query|
       getRes = request(testRoot);
       res = getRes.text();

       postMsg = <foo>foo</foo>;
       postRes = request(testRoot, "post", postMsg);
       res = res + postRes.text();

       putMsg = <bar>bar</bar>;
       putRes = request(testRoot, "put", putMsg);
       res = res + putRes.text();

       request(testRoot, "delete");
       reply(res);
   }
}
{% endhighlight %}

Header example:

{% highlight simpel %}
req = <order><id>{orderId}</id></order>
req.headers.basicAuth.login = "scott";
req.headers.basicAuth.password = "tiger";
req.headers.Accept = "application/xml";
request(orderingSystem, "POST", req);
{% endhighlight %}

h2(#running_env). Running Environment

{% highlight simpel %}
{% endhighlight %}
{% highlight text %}
{% endhighlight %}

